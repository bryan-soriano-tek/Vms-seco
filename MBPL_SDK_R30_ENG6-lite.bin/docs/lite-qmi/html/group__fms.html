<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Linux SDK (lite-qmi): Firmware Management Service (FMS)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Linux SDK (lite-qmi)
   &#160;<span id="projectnumber">MBPL_SDK_R30_ENG6</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__fms.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Firmware Management Service (FMS)</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:fms_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fms_8h.html">fms.h</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:qa_gobi_api_fms_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qa_gobi_api_fms_8h.html">qaGobiApiFms.h</a></td></tr>
<tr class="memdesc:qa_gobi_api_fms_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Firmware Management Service API function prototypes. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_carrier_image__t.html">CarrierImage_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpack__fms___get_images_preference__t.html">pack_fms_GetImagesPreference_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_f_m_s_image_element.html">FMSImageElement</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_f_m_s_pref_image_list.html">FMSPrefImageList</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunpack__fms___get_images_preference__t.html">unpack_fms_GetImagesPreference_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpack__fms___get_stored_images__t.html">pack_fms_GetStoredImages_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_f_m_s_image_id_element.html">FMSImageIdElement</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_f_m_s_image_i_d_entries.html">FMSImageIDEntries</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_f_m_s_image_list.html">FMSImageList</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunpack__fms___get_stored_images__t.html">unpack_fms_GetStoredImages_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpack__fms___set_images_preference__t.html">pack_fms_SetImagesPreference_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunpack__fms___set_images_preference__t.html">unpack_fms_SetImagesPreference_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpack__fms___delete_stored_image__t.html">pack_fms_DeleteStoredImage_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structimage__sublist__entry__t.html">image_sublist_entry_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstored__images__list__t.html">stored_images_list_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structunpack__fms___slqs_get_stored_images__t.html">unpack_fms_SlqsGetStoredImages_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfwinfo__s.html">fwinfo_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structslqsfwinfo__s.html">slqsfwinfo_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_image_element.html">ImageElement</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pref_image_list.html">PrefImageList</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_image_id_element.html">ImageIdElement</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_image_i_d_entries.html">ImageIDEntries</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_image_list.html">ImageList</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structs_get_device_series_result.html">sGetDeviceSeriesResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_w_i___s_t_r_u_c_t___carrier_image.html">SWI_STRUCT_CarrierImage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_curr_image_info.html">CurrImageInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_current_img_list.html">CurrentImgList</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gadff83a97c665c31116564b0ef75dcf40"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fms.html#gadff83a97c665c31116564b0ef75dcf40">eGobiImageTech</a> { <b>eGOBI_IMG_TECH_CDMA</b> = 0, 
<b>eGOBI_IMG_TECH_UMTS</b>
 }</td></tr>
<tr class="separator:gadff83a97c665c31116564b0ef75dcf40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1dd9e06cbb5f538aba64269a4a3312f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fms.html#gad1dd9e06cbb5f538aba64269a4a3312f">eGobiImageCarrier</a> { <br />
&#160;&#160;<b>eGOBI_IMG_CAR_GENERIC</b> = 1, 
<b>eGOBI_IMG_CAR_FACTORY</b>, 
<b>eGOBI_IMG_CAR_NORF</b>, 
<b>eGOBI_IMG_CAR_VERIZON</b> = 101, 
<br />
&#160;&#160;<b>eGOBI_IMG_CAR_SPRINT</b>, 
<b>eGOBI_IMG_CAR_ALLTEL</b>, 
<b>eGOBI_IMG_CAR_BELL</b>, 
<b>eGOBI_IMG_CAR_TELUS</b>, 
<br />
&#160;&#160;<b>eGOBI_IMG_CAR_US</b>, 
<b>eGOBI_IMG_CAR_TELSTRA1</b>, 
<b>eGOBI_IMG_CAR_CHINA_UNICOM</b>, 
<b>eGOBI_IMG_CAR_TELCOM_NZ</b>, 
<br />
&#160;&#160;<b>eGOBI_IMG_CAR_SK_TELCOM1</b>, 
<b>eGOBI_IMG_CAR_RELIANCE1</b>, 
<b>eGOBI_IMG_CAR_TATA</b>, 
<b>eGOBI_IMG_CAR_METROPCS</b>, 
<br />
&#160;&#160;<b>eGOBI_IMG_CAR_LEAP</b>, 
<b>eGOBI_IMG_CAR_KDDI</b>, 
<b>eGOBI_IMG_CAR_IUSACELL</b>, 
<b>eGOBI_IMG_CAR_CHINA_TELECOM</b>, 
<br />
&#160;&#160;<b>eGOBI_IMG_CAR_OMH</b>, 
<b>eGOBI_IMG_CAR_GENERIC_CDMA</b>, 
<b>eGOBI_IMG_CAR_ATT</b> = 201, 
<b>eGOBI_IMG_CAR_VODAFONE</b>, 
<br />
&#160;&#160;<b>eGOBI_IMG_CAR_TMOBILE</b>, 
<b>eGOBI_IMG_CAR_ORANGE</b>, 
<b>eGOBI_IMG_CAR_TELEFONICA</b>, 
<b>eGOBI_IMG_CAR_TELCOM_ITALIA</b>, 
<br />
&#160;&#160;<b>eGOBI_IMG_CAR_3</b>, 
<b>eGOBI_IMG_CAR_O2</b>, 
<b>eGOBI_IMG_CAR_SFR</b>, 
<b>eGOBI_IMG_CAR_SWISSCOM</b>, 
<br />
&#160;&#160;<b>eGOBI_IMG_CAR_CHINA_MOBILE</b>, 
<b>eGOBI_IMG_CAR_TELSTRA2</b>, 
<b>eGOBI_IMG_CAR_SINGTEL_OPTUS</b>, 
<b>eGOBI_IMG_CAR_RELIANCE2</b>, 
<br />
&#160;&#160;<b>eGOBI_IMG_CAR_BHARTI</b>, 
<b>eGOBI_IMG_CAR_NTT_DOCOMO</b>, 
<b>eGOBI_IMG_CAR_EMOBILE</b>, 
<b>eGOBI_IMG_CAR_SOFTBANK</b>, 
<br />
&#160;&#160;<b>eGOBI_IMG_CAR_KT_FREETEL</b>, 
<b>eGOBI_IMG_CAR_SK_TELCOM2</b>, 
<b>eGOBI_IMG_CAR_TELENOR</b>, 
<b>eGOBI_IMG_CAR_NETCOM</b>, 
<br />
&#160;&#160;<b>eGOBI_IMG_CAR_TELIASONERA</b>, 
<b>eGOBI_IMG_CAR_AMX_TELCEL</b>, 
<b>eGOBI_IMG_CAR_BRASIL_VIVO</b>, 
<b>eGOBI_IMG_CAR_AERIS</b>, 
<br />
&#160;&#160;<b>eGOBI_IMG_CAR_ROGERS</b>
<br />
 }</td></tr>
<tr class="separator:gad1dd9e06cbb5f538aba64269a4a3312f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga148b7871cdb55a575e2b9ed31696fb38"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fms.html#ga148b7871cdb55a575e2b9ed31696fb38">eGobiImageRegion</a> { <br />
&#160;&#160;<b>eGOBI_IMG_REG_NA</b> = 0, 
<b>eGOBI_IMG_REG_LA</b>, 
<b>eGOBI_IMG_REG_EU</b>, 
<b>eGOBI_IMG_REG_ASIA</b>, 
<br />
&#160;&#160;<b>eGOBI_IMG_REG_AUS</b>, 
<b>eGOBI_IMG_REG_GLOBAL</b>
<br />
 }</td></tr>
<tr class="separator:ga148b7871cdb55a575e2b9ed31696fb38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07823007fb145fe5224ac8e8aef1eb25"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fms.html#ga07823007fb145fe5224ac8e8aef1eb25">eGobiImageGPS</a> { <b>eGOBI_IMG_GPS_NONE</b> = 0, 
<b>eGOBI_IMG_GPS_STAND_ALONE</b>, 
<b>eGOBI_IMG_GPS_ASSISTED</b>, 
<b>eGOBI_IMG_GPS_NO_XTRA</b>
 }</td></tr>
<tr class="separator:ga07823007fb145fe5224ac8e8aef1eb25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5885e393d2414ca7249b5f6bcdcf458"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fms.html#gab5885e393d2414ca7249b5f6bcdcf458">eGobiDeviceSeries</a> { <br />
&#160;&#160;<b>eGOBI_DEV_SERIES_UNKNOWN</b> = -1, 
<b>eGOBI_DEV_SERIES_NON_GOBI</b> = 0, 
<b>eGOBI_DEV_SERIES_G3K</b>, 
<b>eGOBI_DEV_SERIES_SIERRA_GOBI</b>, 
<br />
&#160;&#160;<b>eGOBI_DEV_SERIES_9X15</b>, 
<b>eGOBI_DEV_SERIES_9X30</b>, 
<b>eGOBI_DEV_SERIES_9X07_9X50</b>, 
<b>eGobi_DEV_SERIES_MC83</b>
<br />
 }</td></tr>
<tr class="separator:gab5885e393d2414ca7249b5f6bcdcf458"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga09dda19c583bcc815d3615cfe3c26422"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fms.html#ga09dda19c583bcc815d3615cfe3c26422">pack_fms_GetImagesPreference</a> (<a class="el" href="structpack__qmi__t.html">pack_qmi_t</a> *pCtx, uint8_t *pReqBuf, uint16_t *pLen, void *reqArg)</td></tr>
<tr class="separator:ga09dda19c583bcc815d3615cfe3c26422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb2a01c16aa1fb91fe48e7385bb0bbce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fms.html#gafb2a01c16aa1fb91fe48e7385bb0bbce">unpack_fms_GetImagesPreference</a> (uint8_t *pResp, uint16_t respLen, <a class="el" href="structunpack__fms___get_images_preference__t.html">unpack_fms_GetImagesPreference_t</a> *pOutput)</td></tr>
<tr class="separator:gafb2a01c16aa1fb91fe48e7385bb0bbce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25e730e0e8bdf00698b2e7962c07e62f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fms.html#ga25e730e0e8bdf00698b2e7962c07e62f">pack_fms_GetStoredImages</a> (<a class="el" href="structpack__qmi__t.html">pack_qmi_t</a> *pCtx, uint8_t *pReqBuf, uint16_t *pLen, <a class="el" href="structpack__fms___get_stored_images__t.html">pack_fms_GetStoredImages_t</a> *reqArg)</td></tr>
<tr class="separator:ga25e730e0e8bdf00698b2e7962c07e62f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56c1e0b6bf4af3adae207f32e2e4b857"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fms.html#ga56c1e0b6bf4af3adae207f32e2e4b857">unpack_fms_GetStoredImages</a> (uint8_t *pResp, uint16_t respLen, <a class="el" href="structunpack__fms___get_stored_images__t.html">unpack_fms_GetStoredImages_t</a> *pOutput)</td></tr>
<tr class="separator:ga56c1e0b6bf4af3adae207f32e2e4b857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga989baa74bedf2d04ba094fc9cd82fa90"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fms.html#ga989baa74bedf2d04ba094fc9cd82fa90">pack_fms_SetImagesPreference</a> (<a class="el" href="structpack__qmi__t.html">pack_qmi_t</a> *pCtx, uint8_t *pReqBuf, uint16_t *pLen, <a class="el" href="structpack__fms___set_images_preference__t.html">pack_fms_SetImagesPreference_t</a> *reqArg)</td></tr>
<tr class="separator:ga989baa74bedf2d04ba094fc9cd82fa90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bb31c4b9c613c7f03ead350b5b1699e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fms.html#ga3bb31c4b9c613c7f03ead350b5b1699e">unpack_fms_SetImagesPreference</a> (uint8_t *pResp, uint16_t respLen, <a class="el" href="structunpack__fms___set_images_preference__t.html">unpack_fms_SetImagesPreference_t</a> *pOutput)</td></tr>
<tr class="separator:ga3bb31c4b9c613c7f03ead350b5b1699e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87ec43b2dbebaa16389615b2e3a91c1d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fms.html#ga87ec43b2dbebaa16389615b2e3a91c1d">GetValidFwPriCombinations</a> (<a class="el" href="struct_f_m_s_image_list.html">FMSImageList</a> *pStoredImageList, uint32_t *pValidCombinationSize, <a class="el" href="struct_carrier_image__t.html">CarrierImage_t</a> *pValidCombinations)</td></tr>
<tr class="separator:ga87ec43b2dbebaa16389615b2e3a91c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebb3737dbb4de1b6428e82f59d1e3d2d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fms.html#gaebb3737dbb4de1b6428e82f59d1e3d2d">pack_fms_DeleteStoredImage</a> (<a class="el" href="structpack__qmi__t.html">pack_qmi_t</a> *pCtx, uint8_t *pReqBuf, uint16_t *pLen, <a class="el" href="structpack__fms___delete_stored_image__t.html">pack_fms_DeleteStoredImage_t</a> *pReqParam)</td></tr>
<tr class="separator:gaebb3737dbb4de1b6428e82f59d1e3d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6316734fd5a2fd88f36c9cc9ad8a344"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fms.html#gaf6316734fd5a2fd88f36c9cc9ad8a344">unpack_fms_DeleteStoredImage</a> (uint8_t *pResp, uint16_t respLen, <a class="el" href="structunpack__result__t.html">unpack_fms_DeleteStoredImage_t</a> *pOutput)</td></tr>
<tr class="separator:gaf6316734fd5a2fd88f36c9cc9ad8a344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16db49be7a4086d12790801e8edf1aaa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fms.html#ga16db49be7a4086d12790801e8edf1aaa">pack_fms_SlqsGetStoredImages</a> (<a class="el" href="structpack__qmi__t.html">pack_qmi_t</a> *pCtx, uint8_t *pReqBuf, uint16_t *pLen)</td></tr>
<tr class="separator:ga16db49be7a4086d12790801e8edf1aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dcb2cccae8d1f1ab8efbbbb02f89115"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fms.html#ga6dcb2cccae8d1f1ab8efbbbb02f89115">unpack_fms_SlqsGetStoredImages</a> (uint8_t *pResp, uint16_t respLen, <a class="el" href="structunpack__fms___slqs_get_stored_images__t.html">unpack_fms_SlqsGetStoredImages_t</a> *pOutput)</td></tr>
<tr class="separator:ga6dcb2cccae8d1f1ab8efbbbb02f89115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c8c09b787f9b9f2e349f15e0097dc71"><td class="memItemLeft" align="right" valign="top">ULONG&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fms.html#ga0c8c09b787f9b9f2e349f15e0097dc71">GetImageStore</a> (WORD imageStorePathSize, CHAR *pImageStorePath)</td></tr>
<tr class="separator:ga0c8c09b787f9b9f2e349f15e0097dc71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fe4c18e57640a15ccd2f11aac9a55cf"><td class="memItemLeft" align="right" valign="top">ULONG&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fms.html#ga0fe4c18e57640a15ccd2f11aac9a55cf">SLQSGetFirmwareInfo</a> (struct <a class="el" href="structqmifwinfo__s.html">qmifwinfo_s</a> *pinfo)</td></tr>
<tr class="separator:ga0fe4c18e57640a15ccd2f11aac9a55cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad620191077dbae26baad2239b67162a7"><td class="memItemLeft" align="right" valign="top">ULONG&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fms.html#gad620191077dbae26baad2239b67162a7">SLQSGetImageInfoMC77xx</a> (LPCSTR path, struct <a class="el" href="structqmifwinfo__s.html">qmifwinfo_s</a> *pinfo)</td></tr>
<tr class="separator:gad620191077dbae26baad2239b67162a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a09731fdad1baef7e2183de17cb0802"><td class="memItemLeft" align="right" valign="top">ULONG&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fms.html#ga5a09731fdad1baef7e2183de17cb0802">SLQSGetImageInfoMC83xx</a> (LPCSTR path, struct <a class="el" href="structqmifwinfo__s.html">qmifwinfo_s</a> *pinfo)</td></tr>
<tr class="separator:ga5a09731fdad1baef7e2183de17cb0802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf7d4ab8de20a2e64d6177040b2cf2f2"><td class="memItemLeft" align="right" valign="top">ULONG&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fms.html#gabf7d4ab8de20a2e64d6177040b2cf2f2">SLQSGetImageInfo</a> (LPCSTR path, struct <a class="el" href="structqmifwinfo__s.html">qmifwinfo_s</a> *pinfo)</td></tr>
<tr class="separator:gabf7d4ab8de20a2e64d6177040b2cf2f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga731013b5e4dee4c47c4b253a0dbf57da"><td class="memItemLeft" align="right" valign="top">ULONG&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fms.html#ga731013b5e4dee4c47c4b253a0dbf57da">UpgradeFirmware2k</a> (CHAR *pDestinationPath)</td></tr>
<tr class="separator:ga731013b5e4dee4c47c4b253a0dbf57da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadaf16b0e2448f0439bfd055b33b8a018"><td class="memItemLeft" align="right" valign="top">ULONG&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fms.html#gadaf16b0e2448f0439bfd055b33b8a018">GetImagesPreference</a> (ULONG *pImageListSize, struct <a class="el" href="struct_pref_image_list.html">PrefImageList</a> *pImageList)</td></tr>
<tr class="separator:gadaf16b0e2448f0439bfd055b33b8a018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81d8d33bbe89e0e488dd1df24266ae8d"><td class="memItemLeft" align="right" valign="top">ULONG&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fms.html#ga81d8d33bbe89e0e488dd1df24266ae8d">SetImagesPreference</a> (ULONG imageListSize, BYTE *pImageList, ULONG bForceDownload, BYTE modemIndex, ULONG *pImageTypesSize, BYTE *pImageTypes)</td></tr>
<tr class="separator:ga81d8d33bbe89e0e488dd1df24266ae8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cc16aa2548adb927edf4f34f7fa2c2d"><td class="memItemLeft" align="right" valign="top">ULONG&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fms.html#ga2cc16aa2548adb927edf4f34f7fa2c2d">GetStoredImages</a> (ULONG *pImageListSize, BYTE *pImageList)</td></tr>
<tr class="separator:ga2cc16aa2548adb927edf4f34f7fa2c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c7575843e754917adfa49562fd8b159"><td class="memItemLeft" align="right" valign="top">ULONG&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fms.html#ga4c7575843e754917adfa49562fd8b159">DeleteStoredImage</a> (ULONG imageInfoSize, BYTE *pImageInfo)</td></tr>
<tr class="separator:ga4c7575843e754917adfa49562fd8b159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63613aa3ae8c6a8021b5c7f984e923cf"><td class="memItemLeft" align="right" valign="top">ULONG&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fms.html#ga63613aa3ae8c6a8021b5c7f984e923cf">SLQSGetImageInfo_9x15</a> (LPCSTR path, BYTE imgType, struct <a class="el" href="structslqsfwinfo__s.html">slqsfwinfo_s</a> *pinfo)</td></tr>
<tr class="separator:ga63613aa3ae8c6a8021b5c7f984e923cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4a62045adc65bbf6d8bb03ecbd1b186"><td class="memItemLeft" align="right" valign="top">ULONG&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fms.html#gaf4a62045adc65bbf6d8bb03ecbd1b186">SLQSUpgradeFirmware9x07</a> (CHAR *pDestinationPath)</td></tr>
<tr class="separator:gaf4a62045adc65bbf6d8bb03ecbd1b186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9aaea01bbf7197deb3436d36d8a0f34f"><td class="memItemLeft" align="right" valign="top">ULONG&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fms.html#ga9aaea01bbf7197deb3436d36d8a0f34f">SLQSUpgradeFirmware9x15</a> (CHAR *pDestinationPath)</td></tr>
<tr class="separator:ga9aaea01bbf7197deb3436d36d8a0f34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f99cf3b21695f951688778487343fa1"><td class="memItemLeft" align="right" valign="top">ULONG&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fms.html#ga2f99cf3b21695f951688778487343fa1">SLQSGetBootVersionNumber</a> (ULONG *bootversion)</td></tr>
<tr class="separator:ga2f99cf3b21695f951688778487343fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5ee5e40d1abfd73e325a4b15a4c9268"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fms.html#gae5ee5e40d1abfd73e325a4b15a4c9268">SLQSIsSpkgFormatRequired</a> (void)</td></tr>
<tr class="separator:gae5ee5e40d1abfd73e325a4b15a4c9268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef566a4572f32e44e2e7df619c47b3f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fms.html#gaef566a4572f32e44e2e7df619c47b3f1">SLQSSetSpkgFormatRequired</a> (BYTE isneeded)</td></tr>
<tr class="separator:gaef566a4572f32e44e2e7df619c47b3f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25d8158b819c6dde8cc22def554b55f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fms.html#ga25d8158b819c6dde8cc22def554b55f1">eGetDeviceSeries</a> (struct <a class="el" href="structs_get_device_series_result.html">sGetDeviceSeriesResult</a> *result)</td></tr>
<tr class="separator:ga25d8158b819c6dde8cc22def554b55f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c65d650979b2f71ccb44c1d2f89d34f"><td class="memItemLeft" align="right" valign="top">ULONG&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fms.html#ga9c65d650979b2f71ccb44c1d2f89d34f">SLQSSwiGetAllCarrierImages</a> (ULONG *pNumOfItems, struct <a class="el" href="struct_s_w_i___s_t_r_u_c_t___carrier_image.html">SWI_STRUCT_CarrierImage</a> *pCarrierImages, char *pFolderPath)</td></tr>
<tr class="separator:ga9c65d650979b2f71ccb44c1d2f89d34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ee36146939a7309ea92d06a79809010"><td class="memItemLeft" align="right" valign="top">ULONG&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fms.html#ga1ee36146939a7309ea92d06a79809010">DownloadToSlot</a> (CHAR *path, struct <a class="el" href="structslqsfwinfo__s.html">slqsfwinfo_s</a> fwImgInfo, struct <a class="el" href="structslqsfwinfo__s.html">slqsfwinfo_s</a> priImgInfo, BYTE slot, BYTE forceDownload)</td></tr>
<tr class="separator:ga1ee36146939a7309ea92d06a79809010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c79218e2ef5585c421201ce1e1c5844"><td class="memItemLeft" align="right" valign="top">ULONG&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fms.html#ga8c79218e2ef5585c421201ce1e1c5844">SLQSDownloadFirmwareToSlot</a> (CHAR *pPath, BYTE slot_index, BYTE force_download)</td></tr>
<tr class="separator:ga8c79218e2ef5585c421201ce1e1c5844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f17252d945293204a1eba9a036d0476"><td class="memItemLeft" align="right" valign="top">ULONG&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fms.html#ga2f17252d945293204a1eba9a036d0476">SLQSGetValidFwPriCombinations</a> (struct <a class="el" href="struct_image_list.html">ImageList</a> *pStoredImageList, ULONG *pValidCombinationSize, struct <a class="el" href="struct_s_w_i___s_t_r_u_c_t___carrier_image.html">SWI_STRUCT_CarrierImage</a> *pValidCombinations)</td></tr>
<tr class="separator:ga2f17252d945293204a1eba9a036d0476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3d7740a9fadd4d5f679a1468cc569d8"><td class="memItemLeft" align="right" valign="top">ULONG&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fms.html#gac3d7740a9fadd4d5f679a1468cc569d8">SLQSSetSIMBasedImageSwitching</a> (void)</td></tr>
<tr class="separator:gac3d7740a9fadd4d5f679a1468cc569d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39a60a2b82ee05bc8924d3c9d1548c3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fms.html#ga39a60a2b82ee05bc8924d3c9d1548c3d">SLQSSetCrashStateCheckIgnore</a> (BOOL ignore)</td></tr>
<tr class="separator:ga39a60a2b82ee05bc8924d3c9d1548c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadffcc418f20b22253cc6642a12aebc47"><td class="memItemLeft" align="right" valign="top">ULONG&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fms.html#gadffcc418f20b22253cc6642a12aebc47">SLQSSwiGetFirmwareCurr</a> (<a class="el" href="struct_current_img_list.html">CurrentImgList</a> *pCurrentImgList)</td></tr>
<tr class="separator:gadffcc418f20b22253cc6642a12aebc47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a4e4f42b8870c26c309d8d1f2a431e1"><td class="memItemLeft" align="right" valign="top">ULONG&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fms.html#ga9a4e4f42b8870c26c309d8d1f2a431e1">upgrade_9x07_9x50_fw</a> (LPCSTR path)</td></tr>
<tr class="separator:ga9a4e4f42b8870c26c309d8d1f2a431e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga405f257ad19deec003768ec642a47750"><td class="memItemLeft" align="right" valign="top">ULONG&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fms.html#ga405f257ad19deec003768ec642a47750">SetImagePath</a> (CHAR *path, ULONG isMDM9x15, WORD imgMask, BYTE mdmProtocol)</td></tr>
<tr class="separator:ga405f257ad19deec003768ec642a47750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46b77f2ba8c1139e4e9a0ff1f1f819c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fms.html#ga46b77f2ba8c1139e4e9a0ff1f1f819c2">SLQSIsBootloaderDebugEnabled</a> (const char *szPath, const char *pQsn)</td></tr>
<tr class="separator:ga46b77f2ba8c1139e4e9a0ff1f1f819c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gab5885e393d2414ca7249b5f6bcdcf458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5885e393d2414ca7249b5f6bcdcf458">&#9670;&nbsp;</a></span>eGobiDeviceSeries</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__fms.html#gab5885e393d2414ca7249b5f6bcdcf458">eGobiDeviceSeries</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>enumeration which lists the Device Series </p>

</div>
</div>
<a id="gad1dd9e06cbb5f538aba64269a4a3312f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1dd9e06cbb5f538aba64269a4a3312f">&#9670;&nbsp;</a></span>eGobiImageCarrier</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__fms.html#gad1dd9e06cbb5f538aba64269a4a3312f">eGobiImageCarrier</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>enumeration which lists the carrier supported by the image </p>

</div>
</div>
<a id="ga07823007fb145fe5224ac8e8aef1eb25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07823007fb145fe5224ac8e8aef1eb25">&#9670;&nbsp;</a></span>eGobiImageGPS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__fms.html#ga07823007fb145fe5224ac8e8aef1eb25">eGobiImageGPS</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>enumeration which lists the GPS type supported by the image </p>

</div>
</div>
<a id="ga148b7871cdb55a575e2b9ed31696fb38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga148b7871cdb55a575e2b9ed31696fb38">&#9670;&nbsp;</a></span>eGobiImageRegion</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__fms.html#ga148b7871cdb55a575e2b9ed31696fb38">eGobiImageRegion</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>enumeration which lists the region supported by the image </p>

</div>
</div>
<a id="gadff83a97c665c31116564b0ef75dcf40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadff83a97c665c31116564b0ef75dcf40">&#9670;&nbsp;</a></span>eGobiImageTech</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__fms.html#gadff83a97c665c31116564b0ef75dcf40">eGobiImageTech</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>enumeration which lists the technology supported by the image </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga4c7575843e754917adfa49562fd8b159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c7575843e754917adfa49562fd8b159">&#9670;&nbsp;</a></span>DeleteStoredImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ULONG DeleteStoredImage </td>
          <td>(</td>
          <td class="paramtype">ULONG&#160;</td>
          <td class="paramname"><em>imageInfoSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE *&#160;</td>
          <td class="paramname"><em>pImageInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used to delete the specified image from the device. This API function is only relevant to devices with the ability to store multiple firmware images(see Device Supported section below).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">imageInfoSize</td><td><ul>
<li>The size in BYTEs of the image info array</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pImageInfo</td><td><ul>
<li>The image info list array containing information about the image to be deleted.</li>
<li>See <a class="el" href="struct_image_element.html">ImageElement</a></li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eQCWWAN_ERR_NONE on success, eQCWWAN_xxx error value otherwise</dd></dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="qmerrno_8h_source.html">qmerrno.h</a> for eQCWWAN_xxx error values</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Device Supported: MC83x5/SL9090<br />
 Timeout: 2 Secs </dd></dl>

</div>
</div>
<a id="ga1ee36146939a7309ea92d06a79809010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ee36146939a7309ea92d06a79809010">&#9670;&nbsp;</a></span>DownloadToSlot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ULONG DownloadToSlot </td>
          <td>(</td>
          <td class="paramtype">CHAR *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structslqsfwinfo__s.html">slqsfwinfo_s</a>&#160;</td>
          <td class="paramname"><em>fwImgInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structslqsfwinfo__s.html">slqsfwinfo_s</a>&#160;</td>
          <td class="paramname"><em>priImgInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>forceDownload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API is dedicated for downloading a firmware image into a specific slot. it is used for EM74xx/MC74xx only</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td><ul>
<li>fully qualified path to firmware image to download</li>
</ul>
</td></tr>
    <tr><td class="paramname">fwImgInfo</td><td><ul>
<li>See struct <a class="el" href="structslqsfwinfo__s.html">slqsfwinfo_s</a></li>
</ul>
</td></tr>
    <tr><td class="paramname">priImgInfo</td><td><ul>
<li>See struct <a class="el" href="structslqsfwinfo__s.html">slqsfwinfo_s</a></li>
</ul>
</td></tr>
    <tr><td class="paramname">slot</td><td><ul>
<li>slot id in the modem to store the firmware</li>
</ul>
</td></tr>
    <tr><td class="paramname">forceDownload</td><td><ul>
<li>a flag to force download take place.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="qmerrno_8h_source.html">qmerrno.h</a> for eQCWWAN_xxx error values</dd></dl>
<dl class="section note"><dt>Note</dt><dd>only EM74xx/MC74xx is supported </dd></dl>

</div>
</div>
<a id="ga25d8158b819c6dde8cc22def554b55f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25d8158b819c6dde8cc22def554b55f1">&#9670;&nbsp;</a></span>eGetDeviceSeries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eGetDeviceSeries </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structs_get_device_series_result.html">sGetDeviceSeriesResult</a> *&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Name : eGetDeviceSeries </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td><ul>
<li>See struct <a class="el" href="structs_get_device_series_result.html">sGetDeviceSeriesResult</a></li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structs_get_device_series_result.html">sGetDeviceSeriesResult</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Get Devie Series </dd></dl>

</div>
</div>
<a id="gadaf16b0e2448f0439bfd055b33b8a018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadaf16b0e2448f0439bfd055b33b8a018">&#9670;&nbsp;</a></span>GetImagesPreference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ULONG GetImagesPreference </td>
          <td>(</td>
          <td class="paramtype">ULONG *&#160;</td>
          <td class="paramname"><em>pImageListSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="struct_pref_image_list.html">PrefImageList</a> *&#160;</td>
          <td class="paramname"><em>pImageList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>restore original alignment from stack</p>
<p>Gets the current images preference from the device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pImageListSize</td><td><ul>
<li>Upon input, the size of structure <a class="el" href="struct_image_list.html">ImageList</a> <a class="el" href="struct_image_list.html">ImageList</a></li>
<li>Upon successful output, the number of BYTEs copied to the image list array<br />
 </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pImageList</td><td><ul>
<li>The caller must supply a pointer to a <a class="el" href="struct_image_list.html">ImageList</a> structure typecast as a BYTE pointer</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eQCWWAN_ERR_NONE on success, eQCWWAN_xxx error value otherwise</dd></dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="qmerrno_8h_source.html">qmerrno.h</a> for eQCWWAN_xxx error values</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Timeout: 2 seconds </dd></dl>

</div>
</div>
<a id="ga0c8c09b787f9b9f2e349f15e0097dc71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c8c09b787f9b9f2e349f15e0097dc71">&#9670;&nbsp;</a></span>GetImageStore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ULONG GetImageStore </td>
          <td>(</td>
          <td class="paramtype">WORD&#160;</td>
          <td class="paramname"><em>imageStorePathSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CHAR *&#160;</td>
          <td class="paramname"><em>pImageStorePath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the image store folder, i.e., the folder containing one or more carrier-specific image subfolders compatible with the currently connected QC WWAN device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">imageStorePathSize</td><td><ul>
<li>Maximum number of characters (including NULL terminator) that can be copied to the image store path array.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pImageStorePath</td><td><ul>
<li>The path to the image store</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eQCWWAN_ERR_NONE on success, eQCWWAN_xxx error value otherwise</dd></dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="qmerrno_8h_source.html">qmerrno.h</a> for eQCWWAN_xxx error values </dd></dl>

</div>
</div>
<a id="ga2cc16aa2548adb927edf4f34f7fa2c2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cc16aa2548adb927edf4f34f7fa2c2d">&#9670;&nbsp;</a></span>GetStoredImages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ULONG GetStoredImages </td>
          <td>(</td>
          <td class="paramtype">ULONG *&#160;</td>
          <td class="paramname"><em>pImageListSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE *&#160;</td>
          <td class="paramname"><em>pImageList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>restore original alignment from stack</p>
<p>Gets the list of images stored on the device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pImageListSize</td><td><ul>
<li>Upon input, the size of structure <a class="el" href="struct_image_list.html">ImageList</a> <a class="el" href="struct_image_list.html">ImageList</a></li>
<li>Upon successful output, the number of BYTEs copied to the image list array<br />
 </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pImageList</td><td><ul>
<li>The caller must supply a pointer to a <a class="el" href="struct_image_list.html">ImageList</a> structure typecast as a BYTE pointer</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eQCWWAN_ERR_NONE on success, eQCWWAN_xxx error value otherwise</dd></dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="qmerrno_8h_source.html">qmerrno.h</a> for eQCWWAN_xxx error values</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Device Supported: MC83x5/SL9090<br />
 Timeout: 2 seconds </dd></dl>

</div>
</div>
<a id="ga87ec43b2dbebaa16389615b2e3a91c1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87ec43b2dbebaa16389615b2e3a91c1d">&#9670;&nbsp;</a></span>GetValidFwPriCombinations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t GetValidFwPriCombinations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_f_m_s_image_list.html">FMSImageList</a> *&#160;</td>
          <td class="paramname"><em>pStoredImageList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pValidCombinationSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_carrier_image__t.html">CarrierImage_t</a> *&#160;</td>
          <td class="paramname"><em>pValidCombinations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API distills valid Firmware/PRI combinations from GetStoredImages result</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pStoredImageList</td><td><ul>
<li>image list returned from GetStoredImages</li>
<li>See <a class="el" href="struct_f_m_s_image_list.html">FMSImageList</a></li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pValidCombinationSize</td><td><ul>
<li>number of combination passed in and returned</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pValidCombinations</td><td><ul>
<li>valid combinations returned</li>
<li>See <a class="el" href="struct_carrier_image__t.html">CarrierImage_t</a></li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>eQCWWAN_ERR_INVALID_ARG - Invalid parameters</li>
<li>eQCWWAN_ERR_BUFFER_SZ - No enough element to store combinatons returned</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="qmerrno_8h_source.html">qmerrno.h</a> for eQCWWAN_xxx error values </dd></dl>

</div>
</div>
<a id="gaebb3737dbb4de1b6428e82f59d1e3d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebb3737dbb4de1b6428e82f59d1e3d2d">&#9670;&nbsp;</a></span>pack_fms_DeleteStoredImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pack_fms_DeleteStoredImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpack__qmi__t.html">pack_qmi_t</a> *&#160;</td>
          <td class="paramname"><em>pCtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pReqBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpack__fms___delete_stored_image__t.html">pack_fms_DeleteStoredImage_t</a> *&#160;</td>
          <td class="paramname"><em>pReqParam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pack function for deleting a specified stored image.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pCtx</td><td>qmi request context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pReqBuf</td><td>qmi request buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pLen</td><td>qmi request length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pReqParam</td><td>request prarmeters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eQCWWAN_ERR_NONE on success, eQCWWAN_xxx error value otherwise</dd></dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="qmerrno_8h_source.html">qmerrno.h</a> for eQCWWAN_xxx error values </dd></dl>

</div>
</div>
<a id="ga09dda19c583bcc815d3615cfe3c26422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09dda19c583bcc815d3615cfe3c26422">&#9670;&nbsp;</a></span>pack_fms_GetImagesPreference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pack_fms_GetImagesPreference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpack__qmi__t.html">pack_qmi_t</a> *&#160;</td>
          <td class="paramname"><em>pCtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pReqBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>reqArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get Images Preference pack </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pCtx</td><td>qmi request context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pReqBuf</td><td>qmi request buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pLen</td><td>qmi request length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reqArg</td><td>request parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga25e730e0e8bdf00698b2e7962c07e62f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25e730e0e8bdf00698b2e7962c07e62f">&#9670;&nbsp;</a></span>pack_fms_GetStoredImages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pack_fms_GetStoredImages </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpack__qmi__t.html">pack_qmi_t</a> *&#160;</td>
          <td class="paramname"><em>pCtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pReqBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpack__fms___get_stored_images__t.html">pack_fms_GetStoredImages_t</a> *&#160;</td>
          <td class="paramname"><em>reqArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get Images Preference pack </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pCtx</td><td>qmi request context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pReqBuf</td><td>qmi request buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pLen</td><td>qmi request length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reqArg</td><td>request parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga989baa74bedf2d04ba094fc9cd82fa90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga989baa74bedf2d04ba094fc9cd82fa90">&#9670;&nbsp;</a></span>pack_fms_SetImagesPreference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pack_fms_SetImagesPreference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpack__qmi__t.html">pack_qmi_t</a> *&#160;</td>
          <td class="paramname"><em>pCtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pReqBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpack__fms___set_images_preference__t.html">pack_fms_SetImagesPreference_t</a> *&#160;</td>
          <td class="paramname"><em>reqArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set Images Preference pack </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pCtx</td><td>qmi request context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pReqBuf</td><td>qmi request buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pLen</td><td>qmi request length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reqArg</td><td>request parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga16db49be7a4086d12790801e8edf1aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16db49be7a4086d12790801e8edf1aaa">&#9670;&nbsp;</a></span>pack_fms_SlqsGetStoredImages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pack_fms_SlqsGetStoredImages </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpack__qmi__t.html">pack_qmi_t</a> *&#160;</td>
          <td class="paramname"><em>pCtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pReqBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pack function to retrieve device stored images</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pCtx</td><td>qmi request context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pReqBuf</td><td>qmi request buffer </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pLen</td><td>qmi request length</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eQCWWAN_ERR_NONE on success, eQCWWAN_xxx error value otherwise</dd></dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="qmerrno_8h_source.html">qmerrno.h</a> for eQCWWAN_xxx error values </dd></dl>

</div>
</div>
<a id="ga405f257ad19deec003768ec642a47750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga405f257ad19deec003768ec642a47750">&#9670;&nbsp;</a></span>SetImagePath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ULONG SetImagePath </td>
          <td>(</td>
          <td class="paramtype">CHAR *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ULONG&#160;</td>
          <td class="paramname"><em>isMDM9x15</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD&#160;</td>
          <td class="paramname"><em>imgMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>mdmProtocol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API is used to set image path for firmware download</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td><ul>
<li>fully qualified path to firmware image to download.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isMDM9x15</td><td><ul>
<li>a flag indicates whether it is a MDM9x15 device</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">imgMask</td><td><ul>
<li>image mask to check CWE and NVU files are required or not</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mdmProtocol</td><td><ul>
<li>which firmware download protocol should be used<ul>
<li>0 - SSDP protocol</li>
<li>1 - Firehose protocol</li>
</ul>
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eQCWWAN_ERR_NONE on success, eQCWWAN_xxx error value otherwise</dd></dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="qmerrno_8h_source.html">qmerrno.h</a> for eQCWWAN_xxx error values</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Timeout: 12 seconds<br />
</dd></dl>

</div>
</div>
<a id="ga81d8d33bbe89e0e488dd1df24266ae8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81d8d33bbe89e0e488dd1df24266ae8d">&#9670;&nbsp;</a></span>SetImagesPreference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ULONG SetImagesPreference </td>
          <td>(</td>
          <td class="paramtype">ULONG&#160;</td>
          <td class="paramname"><em>imageListSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE *&#160;</td>
          <td class="paramname"><em>pImageList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ULONG&#160;</td>
          <td class="paramname"><em>bForceDownload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>modemIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ULONG *&#160;</td>
          <td class="paramname"><em>pImageTypesSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE *&#160;</td>
          <td class="paramname"><em>pImageTypes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the current images preference on the device. After this function successfully completes, the device must be reset for the selected image preference to be realized. Additionally, when the returned list of image types that require downloading is not empty, the device opens in QDL mode after the reset. At that point, the QDL portion of this API must be used to download the selected image preference to the device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">imageListSize</td><td><ul>
<li>The size in BYTEs of the image list array</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pImageList</td><td><ul>
<li>The image info list array containing Image Elements<ul>
<li>See <a class="el" href="struct_pref_image_list.html">PrefImageList</a></li>
</ul>
</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bForceDownload</td><td><ul>
<li>Force device to download images from host? 0 - No Nonzero - Yes</li>
</ul>
</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">modemIndex</td><td><ul>
<li>Desired storage index for downloaded modem image (optional, a value of 0xFF indicates unspecified)</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pImageTypesSize</td><td><ul>
<li>Upon input, maximum number of elements that download image types array can contain</li>
<li>Upon successful output, number of elements in download image types array</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pImageTypes</td><td>-The download image types array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eQCWWAN_ERR_NONE on success, eQCWWAN_xxx error value otherwise</dd></dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="qmerrno_8h_source.html">qmerrno.h</a> for eQCWWAN_xxx error values</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Timeout: 2 seconds </dd></dl>

</div>
</div>
<a id="ga8c79218e2ef5585c421201ce1e1c5844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c79218e2ef5585c421201ce1e1c5844">&#9670;&nbsp;</a></span>SLQSDownloadFirmwareToSlot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ULONG SLQSDownloadFirmwareToSlot </td>
          <td>(</td>
          <td class="paramtype">CHAR *&#160;</td>
          <td class="paramname"><em>pPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>slot_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>force_download</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API is used to download firmware to a specific slot id of the modem. It is only applicable for EM74xx variant. This API encapsulates all steps involved in the firmware download process.Hence it is a blocking API call.<br />
 This API will not return until the entire process has been completed. This API will takes significant amount of time (in order of minutes, normally should be less than 10 minutes).</p>
<p>This API Performs the following steps:<br />
</p><ol type="1">
<li>Verifies arguments.<br />
</li>
<li>Retrieve and store the details of the firmware and the PRI file<br />
</li>
<li>Enable device state change callback.<br />
</li>
<li>Enable firmware download callback.<br />
</li>
<li>Set Image preference on the device and reset the device.<br />
</li>
<li>Wait for the firmware to download and device to become ready.<br />
</li>
<li>Check the firmware update status. If fail, return an error.<br />
</li>
<li>If update status is OK, check if current image preference and preferred image preference( from step 2 ) match<br />
</li>
<li>If match, firmware download is successful. otherwise, report FW_PREFERENCE_MISMATCH<br />
 10.Disable callbacks and exit.<br />
 The call to this API blocks until step 7 or 10. This could be a significant amount of time ( in order of minutes ). Also note that the device state change callback and firmware download callback are used internally <br />
 within this API. Hence the user application's instance of these callbacks (if any) are cleared. The user must re-enable these callbacks after a call to this API in order to use them.<br />
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pPath</td><td><ul>
<li>fully qualified path to firmware image to download.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slot_index</td><td><ul>
<li>slot id in the modem to store the firmware</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">force_download</td><td><ul>
<li>a flag to force download take place.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>eQCWWAN_ERR_NONE - Firmware download/Switch success.</li>
<li>eQCWWAN_ERR_INVALID_ARG - The path input does not contain any image</li>
<li>eQCWWAN_ERR_SWIIM_FW_UPDATE_FAIL - Firmware download/switch failed</li>
<li>eQCWWAN_ERR_SWIIM_FW_PREFERENCE_MISMATCH - Download success but device offline due to image preference mismatch ( ref. syslogs for cause )</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="qmerrno_8h_source.html">qmerrno.h</a> for eQCWWAN_xxx error values</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Timeout: NA<br />
</dd></dl>
</li>
</ol>

</div>
</div>
<a id="ga2f99cf3b21695f951688778487343fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f99cf3b21695f951688778487343fa1">&#9670;&nbsp;</a></span>SLQSGetBootVersionNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ULONG SLQSGetBootVersionNumber </td>
          <td>(</td>
          <td class="paramtype">ULONG *&#160;</td>
          <td class="paramname"><em>bootversion</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the boot loader version number</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">bootversion</td><td><ul>
<li>boot loader version presented by a 4 byte integer</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eQCWWAN_ERR_NONE on success, eQCWWAN_xxx error value otherwise</dd></dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="qmerrno_8h_source.html">qmerrno.h</a> for eQCWWAN_xxx error values</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Device Supported: MC9090/SL9090<br />
 Timeout: 2 seconds </dd></dl>

</div>
</div>
<a id="ga0fe4c18e57640a15ccd2f11aac9a55cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fe4c18e57640a15ccd2f11aac9a55cf">&#9670;&nbsp;</a></span>SLQSGetFirmwareInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ULONG SLQSGetFirmwareInfo </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structqmifwinfo__s.html">qmifwinfo_s</a> *&#160;</td>
          <td class="paramname"><em>pinfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns firmware image information from the connected device</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pinfo</td><td><ul>
<li>firmware image information record</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eQCWWAN_ERR_NONE on success, eQCWWAN_xxx error value otherwise</dd></dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="qmerrno_8h_source.html">qmerrno.h</a> for eQCWWAN_xxx error values </dd>
<dd>
struct <a class="el" href="structqmifwinfo__s.html">qmifwinfo_s</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Timeout: 2 Seconds. </dd></dl>

</div>
</div>
<a id="gabf7d4ab8de20a2e64d6177040b2cf2f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf7d4ab8de20a2e64d6177040b2cf2f2">&#9670;&nbsp;</a></span>SLQSGetImageInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ULONG SLQSGetImageInfo </td>
          <td>(</td>
          <td class="paramtype">LPCSTR&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structqmifwinfo__s.html">qmifwinfo_s</a> *&#160;</td>
          <td class="paramname"><em>pinfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns firmware image information from a CWE file or mbn files stored on the host. For CWE, information is returned for the first CWE image found at the specified path. For MBN, the provided path must be located under the image store for the currently connected QC WWAN device. Note that as this API supports multiple firmware image types, it relies on the presence of a supported device. Otherwise, refer to SLQSGetImageInfoMC83xx and SLQSGetImageInfoMC77xx for APIs which do not rely on the presence of a supported device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td><ul>
<li>fully qualified path to folder containing CWE image or MBN images</li>
<li>should use a "/" at the end of the path.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pinfo</td><td><ul>
<li>firmware image information record</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eQCWWAN_ERR_NONE on success, eQCWWAN_xxx error value otherwise</dd></dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="qmerrno_8h_source.html">qmerrno.h</a> for eQCWWAN_xxx error values </dd>
<dd>
struct <a class="el" href="structqmifwinfo__s.html">qmifwinfo_s</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Timeout: N/A<br />
</dd></dl>

</div>
</div>
<a id="ga63613aa3ae8c6a8021b5c7f984e923cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63613aa3ae8c6a8021b5c7f984e923cf">&#9670;&nbsp;</a></span>SLQSGetImageInfo_9x15()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ULONG SLQSGetImageInfo_9x15 </td>
          <td>(</td>
          <td class="paramtype">LPCSTR&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>imgType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structslqsfwinfo__s.html">slqsfwinfo_s</a> *&#160;</td>
          <td class="paramname"><em>pinfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns firmware image information from a CWE file(s) stored on the host. It does not rely on the presence of a supported device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td><ul>
<li>fully qualified path to folder containing the image(s)</li>
<li>should use a "/" at the end of the path.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">imgType</td><td><ul>
<li>2 - Firmware Image( .cwe extension )</li>
<li>3 - PRI Image ( .nvu extension )</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pinfo</td><td><ul>
<li>firmware image information record</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eQCWWAN_ERR_NONE on success, eQCWWAN_xxx error value otherwise</dd></dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="qmerrno_8h_source.html">qmerrno.h</a> for eQCWWAN_xxx error values </dd>
<dd>
struct <a class="el" href="structqmifwinfo__s.html">qmifwinfo_s</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Device Supported: MC73xx<br />
 Timeout: N/A<br />
</dd></dl>

</div>
</div>
<a id="gad620191077dbae26baad2239b67162a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad620191077dbae26baad2239b67162a7">&#9670;&nbsp;</a></span>SLQSGetImageInfoMC77xx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ULONG SLQSGetImageInfoMC77xx </td>
          <td>(</td>
          <td class="paramtype">LPCSTR&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structqmifwinfo__s.html">qmifwinfo_s</a> *&#160;</td>
          <td class="paramname"><em>pinfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns firmware image information from a SPKGS CWE file stored on the host. The information is returned for the first SPKGS CWE image found at the specified path. This API executes independent of a MC77xx being connected to the target.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td><ul>
<li>fully qualified path to folder containing SPKG CWE image</li>
<li>should use a "/" at the end of the path.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pinfo</td><td><ul>
<li>firmware image information record</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eQCWWAN_ERR_NONE on success, eQCWWAN_xxx error value otherwise</dd></dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="qmerrno_8h_source.html">qmerrno.h</a> for eQCWWAN_xxx error values </dd>
<dd>
struct <a class="el" href="structqmifwinfo__s.html">qmifwinfo_s</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Device Supported: MC77xx<br />
 Timeout: N/A<br />
</dd></dl>

</div>
</div>
<a id="ga5a09731fdad1baef7e2183de17cb0802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a09731fdad1baef7e2183de17cb0802">&#9670;&nbsp;</a></span>SLQSGetImageInfoMC83xx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ULONG SLQSGetImageInfoMC83xx </td>
          <td>(</td>
          <td class="paramtype">LPCSTR&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structqmifwinfo__s.html">qmifwinfo_s</a> *&#160;</td>
          <td class="paramname"><em>pinfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns firmware image information from an MBN file located on the host. This API executes independent of a MC83xx being connected to the target.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td><ul>
<li>fully qualified path to folder containing MBN file</li>
<li>should use a "/" at the end of the path.</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pinfo</td><td><ul>
<li>firmware image information record</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eQCWWAN_ERR_NONE on success, eQCWWAN_xxx error value otherwise</dd></dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="qmerrno_8h_source.html">qmerrno.h</a> for eQCWWAN_xxx error values </dd>
<dd>
struct <a class="el" href="structqmifwinfo__s.html">qmifwinfo_s</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Device Supported: MC83xx/SL9090<br />
 Timeout: N/A<br />
</dd></dl>

</div>
</div>
<a id="ga2f17252d945293204a1eba9a036d0476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f17252d945293204a1eba9a036d0476">&#9670;&nbsp;</a></span>SLQSGetValidFwPriCombinations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ULONG SLQSGetValidFwPriCombinations </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_image_list.html">ImageList</a> *&#160;</td>
          <td class="paramname"><em>pStoredImageList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ULONG *&#160;</td>
          <td class="paramname"><em>pValidCombinationSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="struct_s_w_i___s_t_r_u_c_t___carrier_image.html">SWI_STRUCT_CarrierImage</a> *&#160;</td>
          <td class="paramname"><em>pValidCombinations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API distills valid Firmware/PRI combinations from GetStoredImages result</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pStoredImageList</td><td><ul>
<li>image list returned from GetStoredImages</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pValidCombinationSize</td><td><ul>
<li>number of combination passed in and returned</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pValidCombinations</td><td><ul>
<li>valid combinations returned</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>eQCWWAN_ERR_INVALID_ARG - Invalid parameters</li>
<li>eQCWWAN_ERR_BUFFER_SZ - No enough element to store combinatons returned</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="qmerrno_8h_source.html">qmerrno.h</a> for eQCWWAN_xxx error values </dd></dl>

</div>
</div>
<a id="ga46b77f2ba8c1139e4e9a0ff1f1f819c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46b77f2ba8c1139e4e9a0ff1f1f819c2">&#9670;&nbsp;</a></span>SLQSIsBootloaderDebugEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SLQSIsBootloaderDebugEnabled </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pQsn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API is used to check if the bootloader is debug enabled or not for the specified QSN</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">szPath</td><td><ul>
<li>the full path of the provided bootloader or firmware file</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pQsn</td><td><ul>
<li>the QSN of a specific module user wants to check, it is a 4 bytes hex value without the prefix 0X. It can be retrieved by AT command AT!ENTERCND="&lt;password&gt;", AT!SECBOOTCFG?, the first parameter of the response of AT!SECBOOTCFG?.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>values listed below<ul>
<li>-1 bootloader is not debug enabled</li>
<li>0 unbale to retrieve the bootloader debug info</li>
<li>1 bootloader is debug enabled for the provided QSN</li>
<li>4 either szPath or pQsn is invalid (NULL)</li>
<li>18 invalid file </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gae5ee5e40d1abfd73e325a4b15a4c9268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5ee5e40d1abfd73e325a4b15a4c9268">&#9670;&nbsp;</a></span>SLQSIsSpkgFormatRequired()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL SLQSIsSpkgFormatRequired </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if SPKG format download is required for SL9090/MC9090, it returns the value whcih was set by API <a class="el" href="group__fms.html#gaef566a4572f32e44e2e7df619c47b3f1">SLQSSetSpkgFormatRequired()</a></p>
<dl class="section return"><dt>Returns</dt><dd>return TRUE if required, otherwise, return FALSE</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Device Supported: MC9090/SL9090<br />
</dd></dl>

</div>
</div>
<a id="ga39a60a2b82ee05bc8924d3c9d1548c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39a60a2b82ee05bc8924d3c9d1548c3d">&#9670;&nbsp;</a></span>SLQSSetCrashStateCheckIgnore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SLQSSetCrashStateCheckIgnore </td>
          <td>(</td>
          <td class="paramtype">BOOL&#160;</td>
          <td class="paramname"><em>ignore</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API is used to set whether ignore crash state checking before proceed firmware download using the API <a class="el" href="group__fms.html#ga731013b5e4dee4c47c4b253a0dbf57da">UpgradeFirmware2k()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ignore</td><td><ul>
<li>0 - crash state checking applied (default value)</li>
<li>1 - ignore crash state checking</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Device Supported: EM73xx/MC73xx, EM74xx/MC74xx<br />
</dd></dl>

</div>
</div>
<a id="gac3d7740a9fadd4d5f679a1468cc569d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3d7740a9fadd4d5f679a1468cc569d8">&#9670;&nbsp;</a></span>SLQSSetSIMBasedImageSwitching()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ULONG SLQSSetSIMBasedImageSwitching </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API is used to enable the SIM-based Image Switching. The modem will reboot automatically to take effect of the enabing</p>
<dl class="section return"><dt>Returns</dt><dd>eQCWWAN_ERR_NONE on success, eQCWWAN_xxx error value otherwise</dd></dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="qmerrno_8h_source.html">qmerrno.h</a> for eQCWWAN_xxx error values</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Device Supported: EM74xx/MC74xx<br />
</dd></dl>

</div>
</div>
<a id="gaef566a4572f32e44e2e7df619c47b3f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef566a4572f32e44e2e7df619c47b3f1">&#9670;&nbsp;</a></span>SLQSSetSpkgFormatRequired()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SLQSSetSpkgFormatRequired </td>
          <td>(</td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>isneeded</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set if SPKG format download is required for SL9090/MC9090</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isneeded</td><td>[INPUT] user inputs the firmware download method preference<ul>
<li>1 - Gobi3K download method, use mbn files. This is default value</li>
<li>2 - SPKG download method, use cwe file</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Device Supported: MC9090/SL9090<br />
</dd></dl>

</div>
</div>
<a id="ga9c65d650979b2f71ccb44c1d2f89d34f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c65d650979b2f71ccb44c1d2f89d34f">&#9670;&nbsp;</a></span>SLQSSwiGetAllCarrierImages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ULONG SLQSSwiGetAllCarrierImages </td>
          <td>(</td>
          <td class="paramtype">ULONG *&#160;</td>
          <td class="paramname"><em>pNumOfItems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="struct_s_w_i___s_t_r_u_c_t___carrier_image.html">SWI_STRUCT_CarrierImage</a> *&#160;</td>
          <td class="paramname"><em>pCarrierImages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pFolderPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API gets a list of all images stored on both the host and the device</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">pNumOfItems</td><td><ul>
<li>Number of Images{IN/OUT]</li>
</ul>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pCarrierImages</td><td><ul>
<li>See <a class="el" href="struct_s_w_i___s_t_r_u_c_t___carrier_image.html">SWI_STRUCT_CarrierImage</a></li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pFolderPath</td><td><ul>
<li>Path of Input folder</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE/FALSE</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In case pFolderPath is invalid, API does not return invalid path error as SLQSSwiGetAllCarrierImages get carrier images from device also. </dd></dl>

</div>
</div>
<a id="gadffcc418f20b22253cc6642a12aebc47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadffcc418f20b22253cc6642a12aebc47">&#9670;&nbsp;</a></span>SLQSSwiGetFirmwareCurr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ULONG SLQSSwiGetFirmwareCurr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_current_img_list.html">CurrentImgList</a> *&#160;</td>
          <td class="paramname"><em>pCurrentImgList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API gets the currently active images on the device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCurrentImgList</td><td><ul>
<li>Pointer to structure <a class="el" href="struct_current_img_list.html">CurrentImgList</a></li>
<li>See <a class="el" href="struct_current_img_list.html">CurrentImgList</a> for more information</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eQCWWAN_ERR_NONE on success, eQCWWAN_xxx error value otherwise</dd></dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="qmerrno_8h_source.html">qmerrno.h</a> for eQCWWAN_xxx error values</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Technology Supported: NA<br />
 Device Supported: MC73xx, MC74xx/EM74xx<br />
 Timeout: 5 Secs </dd></dl>

</div>
</div>
<a id="gaf4a62045adc65bbf6d8bb03ecbd1b186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4a62045adc65bbf6d8bb03ecbd1b186">&#9670;&nbsp;</a></span>SLQSUpgradeFirmware9x07()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ULONG SLQSUpgradeFirmware9x07 </td>
          <td>(</td>
          <td class="paramtype">CHAR *&#160;</td>
          <td class="paramname"><em>pDestinationPath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API is used to download firmware to a WP760x device.</p>
<p>This API Performs the following steps:<br />
</p><ol type="1">
<li>Verifies arguments.<br />
</li>
<li>Informs the SDK of the firmware upgrade path<br />
</li>
<li>Send the DM command to requests the device reset (device will reset after all open handles are released).<br />
 Upon successful completion, the above steps will have been completed, however, the actual upgrade of the firmware will necessarily then follow.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pDestinationPath</td><td><ul>
<li>fully qualified path to firmware image to download.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eQCWWAN_ERR_NONE on success, eQCWWAN_xxx error value otherwise</dd></dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="qmerrno_8h_source.html">qmerrno.h</a> for eQCWWAN_xxx error values</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Timeout: 5 seconds<br />
</dd></dl>

</div>
</div>
<a id="ga9aaea01bbf7197deb3436d36d8a0f34f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9aaea01bbf7197deb3436d36d8a0f34f">&#9670;&nbsp;</a></span>SLQSUpgradeFirmware9x15()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ULONG SLQSUpgradeFirmware9x15 </td>
          <td>(</td>
          <td class="paramtype">CHAR *&#160;</td>
          <td class="paramname"><em>pDestinationPath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API is used to upgrade firmware on a MC73xx device. This API encapsulates all steps involved in the firmware download process. It is an alternative to any firmware download application. Hence it is a blocking API call. This API will not return until the entire process has been completed.</p>
<p>This API Performs the following steps:<br />
</p><ol type="1">
<li>Verifies arguments.<br />
</li>
<li>Retrieve and store the details of the firmware and the PRI file<br />
</li>
<li>Enable device state change callback.<br />
</li>
<li>Enable firmware download callback.<br />
</li>
<li>Set Image preference on the device and reset the device.<br />
</li>
<li>Wait for the firmware to download and device to become ready.<br />
</li>
<li>Check the firmware update status. If fail, return an error.<br />
</li>
<li>If update status is OK, check if current image preference and preferred image preference( from step 2 ) match<br />
</li>
<li>If match, firmware download is successful.<br />
</li>
<li>If do not match, repeat from step 5 once more.<br />
</li>
<li>Disable callbacks and exit.<br />
 The call to this API blocks until step 7 or 11. This could be a significant amount of time ( in order of minutes ). Also note that the device state change callback and firmware download callback are used internally <br />
 within this API. Hence the user application's instance of these callbacks (if any) are cleared. The user must re-enable these callbacks after a call to this API in order to use them.<br />
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pDestinationPath</td><td><ul>
<li>fully qualified path to firmware image to download. The path must<br />
 end with a forward slash.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>eQCWWAN_ERR_NONE - Firmware download/Switch success.</li>
<li>eQCWWAN_ERR_INVALID_ARG - The path input does not contain any image</li>
<li>eQCWWAN_ERR_SWIIM_FW_UPDATE_FAIL - Firmware download/switch failed</li>
<li>eQCWWAN_ERR_SWIIM_FW_PREFERENCE_MISMATCH - Download success but device offline due to image preference mismatch ( ref. syslogs for cause )</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="qmerrno_8h_source.html">qmerrno.h</a> for eQCWWAN_xxx error values</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Timeout: NA<br />
</dd></dl>
</li>
</ol>

</div>
</div>
<a id="gaf6316734fd5a2fd88f36c9cc9ad8a344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6316734fd5a2fd88f36c9cc9ad8a344">&#9670;&nbsp;</a></span>unpack_fms_DeleteStoredImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int unpack_fms_DeleteStoredImage </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pResp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>respLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structunpack__result__t.html">unpack_fms_DeleteStoredImage_t</a> *&#160;</td>
          <td class="paramname"><em>pOutput</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unpack function for deleting a specified image.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pResp</td><td>qmi response from modem </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">respLen</td><td>qmi response length </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutput</td><td>response unpacked</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eQCWWAN_ERR_NONE on success, eQCWWAN_xxx error value otherwise</dd></dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="qmerrno_8h_source.html">qmerrno.h</a> for eQCWWAN_xxx error values </dd></dl>

</div>
</div>
<a id="gafb2a01c16aa1fb91fe48e7385bb0bbce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb2a01c16aa1fb91fe48e7385bb0bbce">&#9670;&nbsp;</a></span>unpack_fms_GetImagesPreference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int unpack_fms_GetImagesPreference </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pResp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>respLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structunpack__fms___get_images_preference__t.html">unpack_fms_GetImagesPreference_t</a> *&#160;</td>
          <td class="paramname"><em>pOutput</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get Images Preference unpack </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pResp</td><td>qmi response </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">respLen</td><td>qmi response length </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutput</td><td>unpacked response </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga56c1e0b6bf4af3adae207f32e2e4b857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56c1e0b6bf4af3adae207f32e2e4b857">&#9670;&nbsp;</a></span>unpack_fms_GetStoredImages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int unpack_fms_GetStoredImages </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pResp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>respLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structunpack__fms___get_stored_images__t.html">unpack_fms_GetStoredImages_t</a> *&#160;</td>
          <td class="paramname"><em>pOutput</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get Images Preference unpack </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pResp</td><td>qmi response </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">respLen</td><td>qmi response length </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutput</td><td>unpacked response </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3bb31c4b9c613c7f03ead350b5b1699e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3bb31c4b9c613c7f03ead350b5b1699e">&#9670;&nbsp;</a></span>unpack_fms_SetImagesPreference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int unpack_fms_SetImagesPreference </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pResp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>respLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structunpack__fms___set_images_preference__t.html">unpack_fms_SetImagesPreference_t</a> *&#160;</td>
          <td class="paramname"><em>pOutput</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set Images Preference unpack </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pResp</td><td>qmi response </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">respLen</td><td>qmi response length </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutput</td><td>unpacked response </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6dcb2cccae8d1f1ab8efbbbb02f89115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6dcb2cccae8d1f1ab8efbbbb02f89115">&#9670;&nbsp;</a></span>unpack_fms_SlqsGetStoredImages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int unpack_fms_SlqsGetStoredImages </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pResp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>respLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structunpack__fms___slqs_get_stored_images__t.html">unpack_fms_SlqsGetStoredImages_t</a> *&#160;</td>
          <td class="paramname"><em>pOutput</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unpack function to retrieve device stored images</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pResp</td><td>qmi response from modem </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">respLen</td><td>qmi response length </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOutput</td><td>response unpacked</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eQCWWAN_ERR_NONE on success, eQCWWAN_xxx error value otherwise</dd></dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="qmerrno_8h_source.html">qmerrno.h</a> for eQCWWAN_xxx error values </dd></dl>

</div>
</div>
<a id="ga9a4e4f42b8870c26c309d8d1f2a431e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a4e4f42b8870c26c309d8d1f2a431e1">&#9670;&nbsp;</a></span>upgrade_9x07_9x50_fw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ULONG upgrade_9x07_9x50_fw </td>
          <td>(</td>
          <td class="paramtype">LPCSTR&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API is used to download firmware to a 9x07 or 9x50 device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td><ul>
<li>fully qualified path to firmware image to download.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eQCWWAN_ERR_NONE on success, eQCWWAN_xxx error value otherwise</dd></dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="qmerrno_8h_source.html">qmerrno.h</a> for eQCWWAN_xxx error values</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Timeout: 12 seconds<br />
</dd></dl>

</div>
</div>
<a id="ga731013b5e4dee4c47c4b253a0dbf57da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga731013b5e4dee4c47c4b253a0dbf57da">&#9670;&nbsp;</a></span>UpgradeFirmware2k()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ULONG UpgradeFirmware2k </td>
          <td>(</td>
          <td class="paramtype">CHAR *&#160;</td>
          <td class="paramname"><em>pDestinationPath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API is used to download firmware to a MC77xx or Gobi 3000 device. For SL909/MC9090, <a class="el" href="group__fms.html#gaef566a4572f32e44e2e7df619c47b3f1">SLQSSetSpkgFormatRequired()</a> needs to be called in advance to specify the download method, Gobi3K or SPKG download, please refer to the API <a class="el" href="group__fms.html#gaef566a4572f32e44e2e7df619c47b3f1">SLQSSetSpkgFormatRequired()</a> for more details of the input values. If <a class="el" href="group__fms.html#gaef566a4572f32e44e2e7df619c47b3f1">SLQSSetSpkgFormatRequired()</a> is not called in advance, it will us Gobi3K firmware download method (MBN files) as the default download method.</p>
<p>This API Performs the following steps:<br />
</p><ol type="1">
<li>Verifies arguments.<br />
</li>
<li>Verify that device Crash State should be 1 (RESET State).<br />
</li>
<li>Informs the SDK of the firmware upgrade path<br />
</li>
<li>Updates the images preference on the currently connected device.<br />
</li>
<li>Requests the device reset (device will reset after all open handles are released).<br />
 Upon successful completion, the above steps will have been completed, however, the actual upgrade of the firmware will necessarily then follow.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pDestinationPath</td><td><ul>
<li>fully qualified path to firmware image to download. The path must<br />
 end with a forward slash. For a Gobi 3000 device the path should<br />
 specify the carrier image folder index i.e.<br />
 "path_to_carrier_image/carrier_index/" where carrier_index<br />
 is a valid sub-directory entry. For 9x30 devices if pDestinationPath<br />
 is not valid on host, it will use pseudo path for image switching.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>eQCWWAN_ERR_NONE on success, eQCWWAN_xxx error value otherwise</dd></dl>
<dl class="section see"><dt>See also</dt><dd>See <a class="el" href="qmerrno_8h_source.html">qmerrno.h</a> for eQCWWAN_xxx error values</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Timeout: 12 seconds<br />
</dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Nov 23 2022 21:43:57 for Linux SDK (lite-qmi) by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
